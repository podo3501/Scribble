SEH exception with code 0x87d thrown in the test body.
구글테스트에서 이런 문제가 발생했다.
코드에서 메모리 침범이 일어났다.
문제는 static  변수를 쓴 것이었는데 테스트 코드의 특성상 몇번씩 다시 실행을 시키는데
static변수가 초기화 되지 않고 계속해서 더해져서 메모리 침범이 일어났다.
그래서 저 exception이 잡아주는 모양이다.

구글테스트에서 work Directory가 안 맞을때에는
도구->옵션->Test Adapter for Google Test 에 가서 설정을 변경한다.

셰이더의 내용물(b, t, s, u 레지스터)은 늘 자료가 있다고 가정한다.
남아서 넘치는 건 상관없지만 셰이더 데이터에 빈공간이 있으면 안된다.

구글테스트에서 프로젝트 링크에러가 나면 프로젝트->참조에서 걸어주자.

unique_ptr은 pImpl을 쓰고 싶게(전방선언을 하고싶게) 만드는데 여기서 문제점은
unique_ptr은 raw포인터와 같아서 delete방식을 알고 있어야 한다. 즉 소멸자가 정의되지 않으면
오류 C2027 정의되지 않은 형식 '클래스명'을(를) 사용했습니다. 라고 나온다.
그러면 소멸자를 cpp에서 정의해 주면 되긴한데 문제는 생성자가 template인 경우는 이게 또 말썽이다
그래서 template 생성자를 cpp에 명시적으로 선언해 주거나 아니면 중요한 게 아닐 경우는 생성자에 
template를 안 쓰는게 좋은 것 같다.  그리고 에러 메세지가 꼭 저렇게 안나오고 애매하게 나오는 경우도
있으니 주의를 요함
생성자 소멸자 둘다 cpp에 정의한다. h에 = default 해도 소용없음 
*변수를 h에 선언할때 초기화 할수 있는데 초기화를 하면 cpp에 정의해도 필요없게 됨. 선언과 동시에 초기화를
하지 않아야 함.ex) std::unique_ptr<Material> m_materials; <-- m_materials{} 중괄호 없애야함.

microsoft c++ 예외: poco::notfoundexception 출력창에 나왔는데 nvdia 디바이스 업데이트 이후 없어짐

구글테스트에서 window msg 처리를 안 하고 풀 테스트를 할 경우 그 메세지가 살아남아서 다른 테스트에
영향을 끼침. 그래서 소멸자에 메세지를 처리하도록(리스너 제거) 하니 정상적으로 동작함

C1189: #error:  "No Target Architecture" include <windows.h> 하자

새로운 것을 추가하면 버그가 생기고 버그가 생긴 부분을 테스트코드에 확인차 넣을려고 하면, 안되는 경우들이 있다.
새로운 구조가 필요해서 그런 것인데, 새로운 구조를 하지 않고서도 간단히 고칠수도 있지만, 결국에는 새로운
구조로 가게 되어 있고, 새로운 구조로 가고(리팩토링후) 테스트 코드를 작성한 후에 통과되는지 확인한다.

